<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Village Shopkeeper</title>
    
    <!-- Load Three.js from more reliable CDN sources -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- We don't need the Anthropic SDK on client side anymore -->
    
    <!-- Load environment variables -->
    <script src="env-config.js"></script>
    
    <!-- Load our interaction handling script -->
    <script src="js/interactions.js"></script>
    
    <!-- Embed our own OrbitControls implementation -->
    <script>
        // Simple OrbitControls implementation that doesn't rely on external dependencies
        // Based on the Three.js OrbitControls but simplified for our needs
        (function() {
            // Create OrbitControls constructor - significantly simplified from before
            THREE.OrbitControls = function(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement || document.createElement('div');
                this.enabled = true;
                
                // API
                this.enableDamping = false;
                this.dampingFactor = 0.05;
                this.enableZoom = true;
                this.zoomSpeed = 1.0;
                this.enableRotate = true;
                this.rotateSpeed = 1.0;
                this.enablePan = false; // Disable panning for simplicity
                this.minDistance = 3;
                this.maxDistance = 30;
                this.minPolarAngle = 0; // radians
                this.maxPolarAngle = Math.PI / 2; // radians
                
                // Internals
                var scope = this;
                var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1 };
                var state = STATE.NONE;
                
                // Target point that camera rotates around
                this.target = new THREE.Vector3();
                
                // Current camera position in spherical coordinates
                var spherical = new THREE.Spherical();
                var sphericalDelta = new THREE.Spherical();
                var scale = 1;
                var zoomChanged = false;
                
                // Mouse position tracking
                var rotateStart = new THREE.Vector2();
                var rotateEnd = new THREE.Vector2();
                var rotateDelta = new THREE.Vector2();
                
                // Update camera position based on spherical coordinates
                this.update = function() {
                    var offset = new THREE.Vector3();
                    var position = scope.camera.position;
                    
                    // Get current position as offset from target
                    offset.copy(position).sub(scope.target);
                    
                    // Convert to spherical coordinates
                    spherical.setFromVector3(offset);
                    
                    // Apply rotation changes
                    spherical.theta += sphericalDelta.theta;
                    spherical.phi += sphericalDelta.phi;
                    
                    // Restrict phi to be between min and max
                    spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                    spherical.makeSafe();
                    
                    // Apply zoom
                    spherical.radius *= scale;
                    spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                    
                    // Convert back to cartesian coordinates
                    offset.setFromSpherical(spherical);
                    
                    // Update camera position
                    position.copy(scope.target).add(offset);
                    scope.camera.lookAt(scope.target);
                    
                    // Reset changes
                    sphericalDelta.set(0, 0, 0);
                    scale = 1;
                    
                    return true; // Always return true to ensure animations continue
                };
                
                // Mouse down handler
                function onMouseDown(event) {
                    if (!scope.enabled) return;
                    
                    event.preventDefault();
                    
                    switch (event.button) {
                        case 0: // Left mouse button - rotate
                            rotateStart.set(event.clientX, event.clientY);
                            state = STATE.ROTATE;
                            break;
                    }
                    
                    scope.domElement.addEventListener('mousemove', onMouseMove, false);
                    scope.domElement.addEventListener('mouseup', onMouseUp, false);
                }
                
                // Mouse move handler - simplified to just handle rotation
                function onMouseMove(event) {
                    if (!scope.enabled) return;
                    
                    event.preventDefault();
                    
                    if (state === STATE.ROTATE) {
                        rotateEnd.set(event.clientX, event.clientY);
                        rotateDelta.subVectors(rotateEnd, rotateStart);
                        
                        // Calculate rotation angles based on mouse movement
                        sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / scope.domElement.clientWidth * scope.rotateSpeed;
                        sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / scope.domElement.clientHeight * scope.rotateSpeed;
                        
                        rotateStart.copy(rotateEnd);
                        
                        scope.update();
                    }
                }
                
                // Mouse up handler
                function onMouseUp() {
                    scope.domElement.removeEventListener('mousemove', onMouseMove, false);
                    scope.domElement.removeEventListener('mouseup', onMouseUp, false);
                    state = STATE.NONE;
                }
                
                // Mouse wheel handler - simplified zoom
                function onMouseWheel(event) {
                    if (!scope.enabled || !scope.enableZoom) return;
                    
                    event.preventDefault();
                    
                    if (event.deltaY < 0) {
                        scale /= 1.1; // Zoom in
                    } else {
                        scale *= 1.1; // Zoom out
                    }
                    
                    scope.update();
                }
                
                // Set up event listeners
                this.domElement.addEventListener('contextmenu', function(event) { event.preventDefault(); }, false);
                this.domElement.addEventListener('mousedown', onMouseDown, false);
                this.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
                
                // Initial update
                this.update();
                
                console.log('Simplified OrbitControls initialized successfully');
            };
        })();
    </script>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(51, 25, 0, 0.85);
            color: #FFD700;
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid #8B4513;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        
        .fade-out {
            opacity: 0;
        }
        
        #ui-container {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Welcome Screen Styles */
        #welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 1s ease-in-out;
        }
        
        #welcome-content {
            text-align: center;
            background-color: rgba(51, 25, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            border: 3px solid #8B4513;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }
        
        #welcome-screen h1 {
            color: #FFD700;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #welcome-screen p {
            color: #FFF;
            font-size: 1.2em;
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        #wallet-input {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid #8B4513;
            border-radius: 5px;
            margin-bottom: 15px;
            color: #333;
        }
        
        #validation-message {
            font-size: 0.9em;
            margin-bottom: 15px;
            color: #FFD700;
            min-height: 20px;
        }
        
        #enter-button {
            background-color: #8B4513;
            color: #FFD700;
            border: none;
            padding: 12px 30px;
            font-size: 1.2em;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        #enter-button:hover:not(:disabled) {
            background-color: #A0522D;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        #enter-button:disabled {
            background-color: #6b5045;
            color: #cca752;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        #interaction-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(51, 25, 0, 0.9);
            color: #FFD700;
            padding: 20px;
            border-radius: 10px;
            border: 3px solid #8B4513;
            width: 300px;
            pointer-events: auto;
        }
        
        .hidden {
            display: none;
        }
        
        #shop-items {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .item {
            width: 45%;
            background-color: rgba(139, 69, 19, 0.5);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .item-image {
            width: 50px;
            height: 50px;
            margin: 0 auto 10px;
            border-radius: 50%;
        }
        
        .potion-img {
            background-color: #FF0000;
        }
        
        .sword-img {
            background-color: #C0C0C0;
        }
        
        button {
            background-color: #8B4513;
            color: #FFD700;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            font-weight: bold;
        }
        
        button:hover {
            background-color: #A0522D;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
        
        /* Chat window styles */
        #chat-window {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 400px; /* Increased from 350px */
            background-color: rgba(51, 25, 0, 0.9);
            color: #FFD700;
            border-radius: 10px;
            border: 3px solid #8B4513;
            pointer-events: auto;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateY(20px);
            opacity: 0;
            overflow: hidden;
            max-height: 85vh; /* Use viewport height instead of fixed pixels - 85% of viewport height */
            height: 85vh; /* Set a fixed height to fill most of the screen */
            display: flex;
            flex-direction: column;
            z-index: 100; /* Ensure it's above other elements */
        }
        
        #chat-window.active {
            transform: translateY(0);
            opacity: 1;
        }
        
        #chat-header {
            background-color: rgba(139, 69, 19, 0.8);
            padding: 10px;
            border-radius: 7px 7px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #chat-messages {
            padding: 10px;
            height: calc(85vh - 120px); /* Calculate height based on viewport height minus space for header and input */
            overflow-y: scroll; /* Change from auto to scroll to always show scrollbar */
            display: flex;
            flex-direction: column;
            pointer-events: all !important; /* Use all instead of auto and make it !important */
            margin-right: 2px; /* Add a small margin to prevent content touching scrollbar */
            -webkit-user-select: text; /* Enable text selection */
            user-select: text;
            z-index: 101; /* Higher than chat-window */
            flex-grow: 1; /* Allow it to grow to fill available space */
        }
        
        /* Custom scrollbar styling */
        #chat-messages::-webkit-scrollbar {
            width: 10px;
        }
        
        #chat-messages::-webkit-scrollbar-track {
            background: rgba(139, 69, 19, 0.3);
            border-radius: 5px;
        }
        
        #chat-messages::-webkit-scrollbar-thumb {
            background: rgba(139, 69, 19, 0.8);
            border-radius: 5px;
            border: 2px solid rgba(139, 69, 19, 0.3);
        }
        
        #chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 69, 19, 1);
        }
        
        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
        }
        
        .shopkeeper-message {
            background-color: rgba(139, 69, 19, 0.5);
            align-self: flex-start;
            border-bottom-left-radius: 0;
        }
        
        .player-message {
            background-color: rgba(25, 70, 120, 0.5);
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }
        
        /* New chat input styles */
        #chat-input-container {
            display: flex;
            padding: 10px;
            border-top: 1px solid rgba(139, 69, 19, 0.5);
        }
        
        #chat-input {
            flex-grow: 1;
            padding: 8px 12px;
            border-radius: 20px;
            border: 1px solid #8B4513;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 14px;
            pointer-events: auto; /* Ensure it receives clicks */
        }
        
        #chat-send-btn {
            background-color: #8B4513;
            color: #FFD700;
            border: none;
            border-radius: 20px;
            padding: 8px 15px;
            margin-left: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            pointer-events: auto; /* Ensure it receives clicks */
        }
        
        #chat-send-btn:hover {
            background-color: #A0522D;
        }
        
        /* Loading indicator for LLM responses */
        .typing-indicator {
            display: flex;
            align-items: center;
            background-color: rgba(139, 69, 19, 0.3);
            border-radius: 12px;
            padding: 8px 12px;
            margin-bottom: 10px;
            align-self: flex-start;
            border-bottom-left-radius: 0;
        }
        
        .typing-indicator span {
            height: 8px;
            width: 8px;
            margin: 0 1px;
            background-color: #FFD700;
            border-radius: 50%;
            display: inline-block;
            opacity: 0.4;
        }
        
        .typing-indicator span:nth-child(1) {
            animation: pulse 1s infinite;
        }
        
        .typing-indicator span:nth-child(2) {
            animation: pulse 1s infinite 0.2s;
        }
        
        .typing-indicator span:nth-child(3) {
            animation: pulse 1s infinite 0.4s;
        }
        
        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }
        
        /* Remove old chat options styles */
        #chat-options {
            display: none;
        }
        
        /* Speech bubble over shopkeeper's head */
        #speech-bubble {
            position: absolute;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            color: #333;
            font-size: 14px;
            max-width: 200px;
            text-align: center;
            pointer-events: none;
            transform: translate(-50%, -120%);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }
        
        #speech-bubble:after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.9) transparent transparent;
        }
        
        #speech-bubble.active {
            opacity: 1;
        }
        
        /* Loading overlay styles */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1500;
            transition: opacity 0.5s ease-in-out;
        }
        
        .loading-content {
            text-align: center;
            background-color: rgba(51, 25, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            border: 3px solid #8B4513;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }
        
        .loading-spinner {
            margin: 20px auto;
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            border-top-color: #FFD700;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #loading-message {
            color: #FFD700;
            font-size: 1.2em;
        }
        
        #close-chat-btn {
            background: none;
            border: none;
            color: #FFD700;
            cursor: pointer;
            padding: 5px 10px;
            font-size: 18px;
            pointer-events: auto; /* Ensure it can receive clicks */
            z-index: 101; /* Make sure it's above other elements */
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #close-chat-btn:hover {
            color: #FFA500;
            background-color: rgba(255, 215, 0, 0.2);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div id="welcome-screen">
        <div id="welcome-content">
            <h1>Nebula - the Shopkeeper Scene</h1>
            <p>Welcome to the Marketplace! Enter your wallet to continue.</p>
            <input type="text" id="wallet-input" placeholder="ENS name (.eth) or Ethereum wallet address (0x...)" autocomplete="off">
            <div id="validation-message"></div>
            <button id="enter-button" disabled>Enter Marketplace</button>
        </div>
    </div>

    <!-- Loading Overlay - New element -->
    <div id="loading-overlay" class="hidden">
        <div class="loading-content">
            <h2>Entering Marketplace</h2>
            <div class="loading-spinner"></div>
            <p id="loading-message">Loading scene ...</p>
        </div>
    </div>

    <div id="container"></div>
    <div id="ui-container">
        <div id="interaction-panel" class="hidden">
            <h3>Shopkeeper</h3>
            <p id="dialog-text">Greetings traveler! Would you like to see my wares?</p>
            <div id="shop-items" class="hidden">
                <div class="item" data-item="potion">
                    <div class="item-image potion-img"></div>
                    <div class="item-name">Healing Potion</div>
                    <div class="item-price">5 coins</div>
                    <button class="buy-btn">Buy</button>
                </div>
                <div class="item" data-item="sword">
                    <div class="item-image sword-img"></div>
                    <div class="item-name">Steel Sword</div>
                    <div class="item-price">25 coins</div>
                    <button class="buy-btn">Buy</button>
                </div>
            </div>
            <button id="view-items-btn">View Items</button>
            <button id="close-btn">Close</button>
        </div>

        <!-- Chat window -->
        <div id="chat-window" class="hidden">
            <div id="chat-header">
                <h3>Talking with Shopkeeper</h3>
                <button id="close-chat-btn">✕</button>
            </div>
            <div id="chat-messages">
                <!-- Chat messages will be added here -->
            </div>
            <div id="chat-input-container">
                <input type="text" id="chat-input" placeholder="Type your message...">
                <button id="chat-send-btn">Send</button>
            </div>
        </div>
        
        <!-- Speech bubble above shopkeeper -->
        <div id="speech-bubble"></div>
    </div>

    <div id="instructions">
        <h3>Controls:</h3>
        <p>Movement: WASD or Arrow Keys to move</p>
        <p>Rotation: Q/E to rotate camera left/right</p>
        <p>Interact: Click on objects</p>
    </div>

    <div id="loading">Loading Three.js...</div>

    <script>
        // Start initialization when everything is loaded
        window.onload = function() {
            // Check if Three.js is loaded
            if (typeof THREE === 'undefined') {
                console.error('THREE is not defined! The Three.js library failed to load.');
                document.getElementById('loading').innerHTML = 'Error loading Three.js!<br>Please check your internet connection and try again.';
                return;
            }
            
            console.log('THREE is loaded successfully!');
            
            // Check if our custom OrbitControls is available
            if (typeof THREE.OrbitControls !== 'function') {
                console.error('OrbitControls is not defined!');
                document.getElementById('loading').innerHTML = 'Error: OrbitControls not available';
                return;
            }
            
            console.log('OrbitControls is available!');
            
            // Global variable to store the wallet address or ENS name
            let address = '';
            
            // Validate Ethereum address or ENS name
            function validateInput(input) {
                // Trim whitespace
                const trimmedInput = input.trim();
                
                // Check if it's an ENS name (ends with .eth)
                if (trimmedInput.toLowerCase().endsWith('.eth')) {
                    // Basic ENS validation - must be at least 5 chars (.eth = 4 chars + at least 1 char for name)
                    return trimmedInput.length >= 5;
                }
                
                // Check if it's an Ethereum address
                // Must start with 0x followed by 40 hex characters
                const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
                return ethAddressRegex.test(trimmedInput);
            }
            
            // Setup validation for the wallet input
            const walletInput = document.getElementById('wallet-input');
            const enterButton = document.getElementById('enter-button');
            const validationMessage = document.getElementById('validation-message');
            
            // Add keypress event listener for Enter/Return key
            walletInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter' && !enterButton.disabled) {
                    enterButton.click();
                }
            });
            
            walletInput.addEventListener('input', function() {
                const input = this.value;
                const isValid = validateInput(input);
                
                enterButton.disabled = !isValid;
                
                if (input === '') {
                    validationMessage.textContent = '';
                } else if (isValid) {
                    if (input.toLowerCase().endsWith('.eth')) {
                        validationMessage.textContent = 'Valid ENS name';
                        validationMessage.style.color = '#4CAF50';
                    } else {
                        validationMessage.textContent = 'Valid Ethereum address';
                        validationMessage.style.color = '#4CAF50';
                    }
                } else {
                    validationMessage.textContent = 'Please enter a valid ENS name or Ethereum address';
                    validationMessage.style.color = '#F44336';
                }
            });
            
            // Set up Enter button to start the scene when clicked
            document.getElementById('enter-button').addEventListener('click', function() {
                // Store the validated address
                address = walletInput.value.trim();
                console.log('User entered address:', address);
                
                // Hide welcome screen with fade-out animation
                const welcomeScreen = document.getElementById('welcome-screen');
                welcomeScreen.style.opacity = '0';
                welcomeScreen.style.transition = 'opacity 1s ease-in-out';
                
                // After the welcome screen fades out, show loading overlay
                setTimeout(function() {
                    welcomeScreen.style.display = 'none';
                    
                    // Show loading overlay
                    const loadingOverlay = document.getElementById('loading-overlay');
                    loadingOverlay.classList.remove('hidden');
                    
                    // Start preloading the greeting
                    preloadInitialGreeting(address)
                        .then(() => {
                            // Fade out the loading overlay
                            loadingOverlay.style.opacity = '0';
                            
                            // Remove loading overlay and initialize the scene
                            setTimeout(() => {
                                loadingOverlay.classList.add('hidden');
                                initializeScene(address);
                            }, 500);
                        })
                        .catch(error => {
                            // Update loading message with error and continue anyway after 2 seconds
                            document.getElementById('loading-message').textContent = 
                                "Couldn't preload greeting. Continuing anyway...";
                            console.error("Error preloading greeting:", error);
                            
                            setTimeout(() => {
                                loadingOverlay.style.opacity = '0';
                                setTimeout(() => {
                                    loadingOverlay.classList.add('hidden');
                                    initializeScene(address);
                                }, 500);
                            }, 2000);
                        });
                }, 1000);
            });
            
            // Function to preload initial greeting before scene is loaded
            // Now returns a promise that resolves when preloading is complete
            function preloadInitialGreeting(userAddress) {
                return new Promise((resolve, reject) => {
                    const API_URL = window.ENV?.API_URL || 'http://localhost:3001/api';
                    
                    console.log('Preloading initial greeting with address:', userAddress);
                    document.getElementById('loading-message').textContent = "Connecting please standby ...";
                    
                    // Create the message payload
                    const payload = {
                        messages: [
                            { role: "user", content: "I've just entered your shop for the first time. Greet me!" }
                        ],
                        userAddress: userAddress
                    };
                    
                    // Set up a timeout - 2 minutes (120,000 ms)
                    let timeoutId = setTimeout(() => {
                        console.error('API request timed out after 2 minutes');
                        document.getElementById('loading-message').textContent = 
                            "Shopkeeper is taking too long to respond. Continuing anyway...";
                        reject(new Error('API request timed out after 2 minutes'));
                    }, 120000);
                    
                    // Cleanup function to ensure timeout is always cleared
                    const cleanup = () => {
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                            timeoutId = null;
                        }
                    };
                    
                    // Make the API call
                    fetch(`${API_URL}/chat`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`API Error: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        cleanup(); // Only clear timeout on successful response
                        
                        // Store the preloaded greeting in a global variable
                        window.preloadedShopkeeperGreeting = data.response;
                        console.log('Initial greeting preloaded successfully:', window.preloadedShopkeeperGreeting);
                        
                        // Update loading message
                        document.getElementById('loading-message').textContent = "Ready to enter marketplace!";
                        
                        // Resolve the promise after a short delay to show "Ready" message
                        setTimeout(resolve, 500);
                    })
                    .catch(error => {
                        console.error('Error preloading initial greeting:', error);
                        document.getElementById('loading-message').textContent = 
                            "Failed to connect to shopkeeper. Continuing anyway...";
                        
                        // Reject after a short delay
                        setTimeout(() => reject(error), 1500);
                    });
                });
            }
        };
        
        // Main scene initialization function
        function initializeScene(userAddress) {
            // Store the user's address for later use
            const address = userAddress;
            console.log('Initializing scene with address:', address);
            
            // Hide loading message
            document.getElementById('loading').style.display = 'none';
            
            // Utility functions
            function calculateDistance(point1, point2) {
                return Math.sqrt(
                    Math.pow(point2.x - point1.x, 2) + 
                    Math.pow(point2.y - point1.y, 2) + 
                    Math.pow(point2.z - point1.z, 2)
                );
            }

            function toggleElement(elementId, show) {
                const element = document.getElementById(elementId);
                if (show) {
                    element.classList.remove('hidden');
                } else {
                    element.classList.add('hidden');
                }
            }

            function createStandardMaterial(parameters = {}) {
                const {
                    color = 0xffffff,
                    roughness = 0.5,
                    metalness = 0.5,
                    map = null,
                    transparent = false,
                    opacity = 1.0,
                    emissive = 0x000000,
                    emissiveIntensity = 0,
                    side = THREE.FrontSide
                } = parameters;

                return new THREE.MeshStandardMaterial({
                    color,
                    roughness,
                    metalness,
                    map,
                    transparent,
                    opacity,
                    emissive,
                    emissiveIntensity,
                    side
                });
            }

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            try {
                console.log('Starting Three.js setup');
                
                // Scene setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue background
                
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                
                console.log('Creating renderer');
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Add the renderer to the container
                const container = document.getElementById('container');
                container.appendChild(renderer.domElement);
                renderer.domElement.style.position = 'absolute';
                renderer.domElement.style.zIndex = '1'; // Set lower z-index than UI
                renderer.domElement.style.width = '100%';
                renderer.domElement.style.height = '100%';
                renderer.domElement.style.touchAction = 'none'; // Prevents default touch behavior
                
                // Check if WebGL context is available and log the result
                if (renderer.getContext()) {
                    console.log('WebGL context is available and working correctly');
                } else {
                    console.error('WebGL context not available or not working correctly');
                    alert('WebGL not available on your device. Please try a different browser or device.');
                }
                
                // Make sure UI container has proper z-index and pointer events
                document.getElementById('ui-container').style.zIndex = '10';
                
                // Ensure interactive UI elements are clickable
                const interactiveElements = [
                    'interaction-panel',
                    'chat-window',
                    'chat-input', 
                    'chat-send-btn',
                    'close-chat-btn',
                    'view-items-btn',
                    'close-btn',
                    'chat-messages'
                ];
                
                interactiveElements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.pointerEvents = 'auto';
                        console.log(`Set pointer-events: auto for ${id}`);
                    }
                });
                
                // Position camera to match the screenshot - more overhead view
                camera.position.set(5, 1.7, 15);
                camera.lookAt(5, 1.7, 5); // Looking straight at the shop from ground level
                
                // Setup keyboard controls instead of mouse controls
                console.log('Setting up keyboard controls...');
                
                // Track which keys are currently pressed
                const keyState = {
                    ArrowUp: false,
                    ArrowDown: false,
                    ArrowLeft: false,
                    ArrowRight: false,
                    w: false,
                    a: false,
                    s: false,
                    d: false,
                    q: false, // For rotating left
                    e: false  // For rotating right
                };
                
                // Handle keydown events
                window.addEventListener('keydown', function(event) {
                    // Check if user is typing in chat input
                    const chatInput = document.getElementById('chat-input');
                    const isTypingInChat = (document.activeElement === chatInput);
                    
                    // Only process keyboard controls if NOT typing in chat
                    if (!isTypingInChat) {
                        if (keyState.hasOwnProperty(event.key)) {
                            keyState[event.key] = true;
                        }
                    }
                });
                
                // Handle keyup events
                window.addEventListener('keyup', function(event) {
                    if (keyState.hasOwnProperty(event.key)) {
                        keyState[event.key] = false;
                    }
                });
                
                // Function to handle keyboard movement
                function handleKeyboardMovement() {
                    const moveSpeed = 0.2; // Adjust speed as needed
                    const rotateSpeed = 0.03; // Adjust rotation speed as needed
                    
                    // Calculate movement direction in camera's local coordinate system
                    const moveDirection = new THREE.Vector3(0, 0, 0);
                    
                    // Forward/backward (Z axis)
                    if (keyState.w || keyState.ArrowUp) {
                        moveDirection.z += moveSpeed; // Changed from -= to +=
                    }
                    if (keyState.s || keyState.ArrowDown) {
                        moveDirection.z -= moveSpeed; // Changed from += to -=
                    }
                    
                    // Left/right (X axis)
                    if (keyState.a || keyState.ArrowLeft) {
                        moveDirection.x -= moveSpeed;
                    }
                    if (keyState.d || keyState.ArrowRight) {
                        moveDirection.x += moveSpeed;
                    }
                    
                    // Apply movement relative to camera's orientation
                    // Extract camera's forward and right vectors
                    const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    cameraDirection.y = 0; // Keep movement in XZ plane
                    cameraDirection.normalize();
                    
                    const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    cameraRight.y = 0; // Keep movement in XZ plane
                    cameraRight.normalize();
                    
                    // Calculate movement vector
                    const movement = new THREE.Vector3();
                    if (moveDirection.z !== 0) {
                        movement.addScaledVector(cameraDirection, moveDirection.z);
                    }
                    if (moveDirection.x !== 0) {
                        movement.addScaledVector(cameraRight, moveDirection.x);
                    }
                    
                    // Apply movement to camera
                    camera.position.add(movement);
                    
                    // Rotation with Q and E keys
                    if (keyState.q) {
                        // Rotate left around Y axis
                        const rotationMatrix = new THREE.Matrix4().makeRotationY(rotateSpeed);
                        const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                        cameraDirection.applyMatrix4(rotationMatrix);
                        const lookAtPoint = new THREE.Vector3().copy(camera.position).add(cameraDirection);
                        camera.lookAt(lookAtPoint);
                    }
                    if (keyState.e) {
                        // Rotate right around Y axis
                        const rotationMatrix = new THREE.Matrix4().makeRotationY(-rotateSpeed);
                        const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                        cameraDirection.applyMatrix4(rotationMatrix);
                        const lookAtPoint = new THREE.Vector3().copy(camera.position).add(cameraDirection);
                        camera.lookAt(lookAtPoint);
                    }
                    
                    // Keep camera at a fixed height
                    camera.position.y = 1.7;
                }
                
                console.log('Keyboard controls configured');
                
                // Remove OrbitControls - we're using keyboard controls instead
                // const controls = new THREE.OrbitControls(camera, renderer.domElement);
                // controls...
                
                // Make sure the renderer DOM element is properly configured
                renderer.domElement.style.touchAction = 'none';
                renderer.domElement.style.position = 'absolute';
                renderer.domElement.style.top = '0';
                renderer.domElement.style.left = '0';
                renderer.domElement.style.width = '100%';
                renderer.domElement.style.height = '100%';
                renderer.domElement.style.zIndex = '1';
                console.log('Renderer DOM element properly configured');
                
                // Setup lighting
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Brighter ambient light
                scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Brighter directional light
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                
                // Configure shadow properties
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;
                
                scene.add(directionalLight);
                
                // Point light for the shop - make it brighter
                const shopLight = new THREE.PointLight(0xf5c542, 1.5, 20);
                shopLight.position.set(5, 5, 5);
                shopLight.castShadow = true;
                scene.add(shopLight);
                
                // Add a helper to visualize the shop position
                const axesHelper = new THREE.AxesHelper(3);
                axesHelper.position.set(5, 0.5, 5);
                scene.add(axesHelper);
                
                // Create ground/street
                const streetGeometry = new THREE.PlaneGeometry(50, 50);
                const streetMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xaaaaaa,
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                const street = new THREE.Mesh(streetGeometry, streetMaterial);
                street.rotation.x = -Math.PI / 2;
                street.receiveShadow = true;
                scene.add(street);
                
                // Add street details
                for (let i = 0; i < 150; i++) {
                    const size = randomInRange(0.2, 0.8);
                    const posX = randomInRange(-25, 25);
                    const posZ = randomInRange(-25, 25);
                    
                    const stoneGeometry = new THREE.BoxGeometry(size, 0.05, size);
                    const stoneMaterial = new THREE.MeshStandardMaterial({
                        color: randomInRange(0x888888, 0xaaaaaa),
                        roughness: 1.0
                    });
                    
                    const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                    stone.position.set(posX, 0.025, posZ);
                    stone.receiveShadow = true;
                    
                    scene.add(stone);
                }
                
                // Create shop with wooden structure as seen in the concept art
                const shopGroup = new THREE.Group();
                shopGroup.position.set(5, 0, 5);
                
                console.log('Creating shop at position:', shopGroup.position);
                
                // Shop base/floor
                const baseGeometry = new THREE.BoxGeometry(8, 0.5, 6);
                const baseMaterial = createStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.8
                });
                const shopBase = new THREE.Mesh(baseGeometry, baseMaterial);
                shopBase.position.y = 0.25;
                shopBase.castShadow = true;
                shopBase.receiveShadow = true;
                shopGroup.add(shopBase);
                
                // Shop walls
                const wallMaterial = createStandardMaterial({ 
                    color: 0xA0522D,
                    roughness: 0.7
                });
                
                // Back wall
                const backWallGeometry = new THREE.BoxGeometry(8, 3, 0.3);
                const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
                backWall.position.set(0, 2, -3);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                shopGroup.add(backWall);
                
                // Side walls
                const sideWallGeometry = new THREE.BoxGeometry(0.3, 3, 6);
                
                const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
                leftWall.position.set(-4, 2, 0);
                leftWall.castShadow = true;
                leftWall.receiveShadow = true;
                shopGroup.add(leftWall);
                
                const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
                rightWall.position.set(4, 2, 0);
                rightWall.castShadow = true;
                rightWall.receiveShadow = true;
                shopGroup.add(rightWall);
                
                // Counter
                const counterGeometry = new THREE.BoxGeometry(7, 1.2, 1.5);
                const counterMaterial = createStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.6
                });
                const counter = new THREE.Mesh(counterGeometry, counterMaterial);
                counter.position.set(0, 1.1, 2);
                counter.castShadow = true;
                counter.receiveShadow = true;
                shopGroup.add(counter);
                
                // Awning/canopy
                const canopyGeometry = new THREE.BoxGeometry(8, 0.1, 3);
                const canopyMaterial = createStandardMaterial({ 
                    color: 0xFF6347, // Red striped awning as in concept
                    roughness: 0.5
                });
                const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                canopy.position.set(0, 3.5, 1);
                canopy.castShadow = true;
                shopGroup.add(canopy);
                
                // Canopy supports
                const supportGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
                const supportMaterial = createStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.7
                });
                
                const leftSupport = new THREE.Mesh(supportGeometry, supportMaterial);
                leftSupport.position.set(-3.5, 3.2, 2.5);
                shopGroup.add(leftSupport);
                
                const rightSupport = new THREE.Mesh(supportGeometry, supportMaterial);
                rightSupport.position.set(3.5, 3.2, 2.5);
                shopGroup.add(rightSupport);
                
                // Add hanging swords from the ceiling
                // Create 3 swords hanging at different heights and positions
                const hangingSwordPositions = [
                    { x: -3.0, y: 2.8, z: 0.5 },  // Leftmost sword position
                    { x: -2.0, y: 3.0, z: 0 },    // Middle sword position 
                    { x: -1.0, y: 2.7, z: 0.5 }   // Closest to shopkeeper but still on left side
                ];
                
                hangingSwordPositions.forEach((pos, index) => {
                    // Create chain to hang the sword
                    const chainGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.7, 8);
                    const chainMaterial = createStandardMaterial({
                        color: 0x333333,
                        roughness: 0.7,
                        metalness: 0.8
                    });
                    const chain = new THREE.Mesh(chainGeometry, chainMaterial);
                    chain.position.set(pos.x, pos.y + 0.35, pos.z);
                    shopGroup.add(chain);
                    
                    // Create the sword handle - now vertical with no gap to chain
                    const handleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
                    const handleMaterial = createStandardMaterial({
                        color: 0x8B4513,
                        roughness: 0.7
                    });
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    // Position handle directly at the end of the chain
                    handle.position.set(pos.x, pos.y, pos.z);
                    shopGroup.add(handle);
                    
                    // Create sword blade - perfectly vertical
                    const bladeLength = 0.8 + (index * 0.2); // Different sized swords
                    const bladeGeometry = new THREE.BoxGeometry(0.18, bladeLength, 0.05);
                    const bladeMaterial = createStandardMaterial({
                        color: 0xC0C0C0,
                        roughness: 0.3,
                        metalness: 0.7
                    });
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    // Position blade below handle with no gap
                    blade.position.set(pos.x, pos.y - (bladeLength/2) - 0.15, pos.z);
                    // No random rotation - perfectly vertical
                    shopGroup.add(blade);
                    
                    // Create sword guard - perfectly horizontal for vertical sword
                    const guardGeometry = new THREE.BoxGeometry(0.35, 0.08, 0.08);
                    const guardMaterial = createStandardMaterial({
                        color: 0xDAA520, // Gold color
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    const guard = new THREE.Mesh(guardGeometry, guardMaterial);
                    guard.position.set(pos.x, pos.y - 0.15, pos.z);
                    shopGroup.add(guard);
                    
                    // Add small hook connecting chain to sword
                    const hookGeometry = new THREE.TorusGeometry(0.05, 0.01, 8, 16, Math.PI);
                    const hookMaterial = createStandardMaterial({
                        color: 0x333333,
                        roughness: 0.5,
                        metalness: 0.8
                    });
                    const hook = new THREE.Mesh(hookGeometry, hookMaterial);
                    hook.position.set(pos.x, pos.y + 0.03, pos.z);
                    hook.rotation.x = Math.PI / 2;
                    shopGroup.add(hook);
                });
                
                // Create shelves for potions
                const shelfMaterial = createStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.7
                });
                
                // Create three shelves
                for (let i = 0; i < 3; i++) {
                    const shelfGeometry = new THREE.BoxGeometry(6, 0.2, 1);
                    const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
                    shelf.position.set(0, 1.5 + i * 0.8, -2.5);
                    shelf.castShadow = true;
                    shelf.receiveShadow = true;
                    shopGroup.add(shelf);
                    
                    // Add potion bottles to shelves
                    for (let j = 0; j < 5; j++) {
                        const potionGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 8);
                        const potionMaterial = createStandardMaterial({
                            color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                            transparent: true,
                            opacity: 0.8,
                            emissive: 0x555555,
                            emissiveIntensity: 0.2
                        });
                        const potion = new THREE.Mesh(potionGeometry, potionMaterial);
                        potion.position.set(-2.5 + j * 1.25, 1.65 + i * 0.8, -2.5);
                        shopGroup.add(potion);
                    }
                }
                
                // Add swords mounted on the back wall
                for (let i = 0; i < 3; i++) {
                    // Sword handle
                    const handleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
                    const handleMaterial = createStandardMaterial({
                        color: 0x8B4513,
                        roughness: 0.7
                    });
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    handle.position.set(-2 + i * 2, 2, -2.8);
                    handle.rotation.x = Math.PI / 2;
                    shopGroup.add(handle);
                    
                    // Sword blade
                    const bladeGeometry = new THREE.BoxGeometry(0.2, 0.05, 1.2);
                    const bladeMaterial = createStandardMaterial({
                        color: 0xC0C0C0,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    blade.position.set(-2 + i * 2, 2, -2.2);
                    shopGroup.add(blade);
                    
                    // Sword guard
                    const guardGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.1);
                    const guardMaterial = createStandardMaterial({
                        color: 0xDAA520,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    const guard = new THREE.Mesh(guardGeometry, guardMaterial);
                    guard.position.set(-2 + i * 2, 2, -2.8);
                    shopGroup.add(guard);
                }
                
                scene.add(shopGroup);
                
                // Create the shopkeeper
                const shopkeeperGroup = new THREE.Group();
                shopkeeperGroup.position.set(5, 1, 3.5); // Moved forward a bit to be more visible
                
                console.log('Creating shopkeeper at position:', shopkeeperGroup.position);
                
                // Create the head - more human-like with lighter skin
                const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                const headMaterial = createStandardMaterial({
                    color: 0xE0C8B0, // Lighter skin tone
                    roughness: 0.7
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.8;
                shopkeeperGroup.add(head);
                
                // Add brown hair
                const hairGeometry = new THREE.BoxGeometry(0.65, 0.2, 0.65);
                const hairMaterial = createStandardMaterial({
                    color: 0x5A3825, // Brown hair
                    roughness: 0.9,
                    metalness: 0.0
                });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.set(0, 2.1, 0); // Position on top of head
                shopkeeperGroup.add(hair);
                
                // Add side hair
                const sideHairGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.5);
                const leftSideHair = new THREE.Mesh(sideHairGeometry, hairMaterial);
                leftSideHair.position.set(-0.35, 1.9, 0);
                shopkeeperGroup.add(leftSideHair);
                
                const rightSideHair = new THREE.Mesh(sideHairGeometry, hairMaterial);
                rightSideHair.position.set(0.35, 1.9, 0);
                shopkeeperGroup.add(rightSideHair);
                
                // Add yellow eyes
                const eyeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.05);
                const eyeMaterial = createStandardMaterial({
                    color: 0x49341C, // Dark brown eyes
                    emissive: 0x49341C,
                    emissiveIntensity: 0.1,
                    roughness: 0.3
                });
                
                // Left eye
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 1.85, 0.31);
                shopkeeperGroup.add(leftEye);
                
                // Right eye
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.15, 1.85, 0.31);
                shopkeeperGroup.add(rightEye);
                
                // Create the mouth
                const mouthGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.05);
                const mouthMaterial = createStandardMaterial({
                    color: 0xA55C3D, // Reddish-brown
                    roughness: 0.7
                });
                const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.7, 0.31);
                shopkeeperGroup.add(mouth);
                
                // Create body with white shirt 
                // White shirt layer - main body
                const shirtGeometry = new THREE.BoxGeometry(0.8, 0.9, 0.5);
                const shirtMaterial = createStandardMaterial({
                    color: 0xF0F0F0, // White/off-white
                    roughness: 0.95, // Very high roughness
                    metalness: 0.0,  // No metalness
                    flatShading: true // Use flat shading
                });
                const shirt = new THREE.Mesh(shirtGeometry, shirtMaterial);
                shirt.position.y = 1.3;
                shopkeeperGroup.add(shirt);
                
                // Add a vest over the shirt - that won't flash
                const vestGeometry = new THREE.BoxGeometry(0.85, 0.85, 0.55);
                const vestMaterial = createStandardMaterial({
                    color: 0x4A7044, // Forest green
                    roughness: 1.0, // Maximum roughness (no specular highlights)
                    metalness: 0.0, // No metalness
                    flatShading: true // Flat shading for stable appearance
                });
                const vest = new THREE.Mesh(vestGeometry, vestMaterial);
                vest.position.y = 1.3;
                vest.position.z = -0.02; // Slightly behind to show white shirt at front
                shopkeeperGroup.add(vest);
                
                // Create cross-strap across chest (X shape)
                const strapGeometry = new THREE.BoxGeometry(0.1, 0.7, 0.05);
                const strapMaterial = createStandardMaterial({
                    color: 0x7E4A30, // Leather brown
                    roughness: 1.0,
                    metalness: 0.0
                });
                
                // First strap (diagonal \)
                const strap1 = new THREE.Mesh(strapGeometry, strapMaterial);
                strap1.position.set(0, 1.3, 0.28);
                strap1.rotation.z = Math.PI / 4; // 45 degrees
                shopkeeperGroup.add(strap1);
                
                // Second strap (diagonal /)
                const strap2 = new THREE.Mesh(strapGeometry, strapMaterial);
                strap2.position.set(0, 1.3, 0.28);
                strap2.rotation.z = -Math.PI / 4; // -45 degrees
                shopkeeperGroup.add(strap2);
                
                // Add arms to shopkeeper
                const armGeometry = new THREE.BoxGeometry(0.3, 0.7, 0.3);
                
                // Left arm - white sleeve
                const armMaterial = createStandardMaterial({
                    color: 0xF0F0F0, // White
                    roughness: 0.95,
                    metalness: 0.0,
                    flatShading: true
                });
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.6, 1.3, 0);
                shopkeeperGroup.add(leftArm);
                
                // Right arm - white sleeve
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.6, 1.3, 0);
                shopkeeperGroup.add(rightArm);
                
                // Set up shadow casting for all parts
                shopkeeperGroup.traverse(function(object) {
                    if (object.isMesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });
                
                // Create a simple bobbing animation for the shopkeeper
                let shopkeeperTime = 0;
                
                // Add shopkeeper to scene
                scene.add(shopkeeperGroup);
                
                // Create floating crystal (similar to the blue gem in concept)
                const crystalGeometry = new THREE.OctahedronGeometry(0.5, 0);
                const crystalMaterial = createStandardMaterial({
                    color: 0x00BFFF,
                    transparent: true,
                    opacity: 0.7,
                    emissive: 0x00BFFF,
                    emissiveIntensity: 0.5
                });
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(5, 1.5, 2); // Raised height for visibility
                crystal.userData = {
                    isItem: true,
                    itemType: 'crystal',
                    itemName: 'Magic Crystal',
                    itemPrice: 50
                };
                scene.add(crystal);
                
                // Create items on the counter
                // Health potion
                const potionGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.4, 8);
                const potionMaterial = createStandardMaterial({
                    color: 0xFF0000, // Red for health potion
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.3
                });
                const potion = new THREE.Mesh(potionGeometry, potionMaterial);
                potion.position.set(4, 1.9, 2);
                potion.userData = {
                    isItem: true,
                    itemType: 'potion',
                    itemName: 'Health Potion',
                    itemPrice: 5
                };
                scene.add(potion);
                
                // Sword for sale on counter
                // Sword handle
                const swordHandleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
                const swordHandleMaterial = createStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.7
                });
                const swordHandle = new THREE.Mesh(swordHandleGeometry, swordHandleMaterial);
                swordHandle.position.set(6, 1.9, 2);
                swordHandle.rotation.x = Math.PI / 2;
                scene.add(swordHandle);
                
                // Sword blade
                const swordBladeGeometry = new THREE.BoxGeometry(0.2, 0.05, 1.2);
                const swordBladeMaterial = createStandardMaterial({
                    color: 0xC0C0C0,
                    roughness: 0.3,
                    metalness: 0.8
                });
                const swordBlade = new THREE.Mesh(swordBladeGeometry, swordBladeMaterial);
                swordBlade.position.set(6, 1.9, 1.4);
                swordBlade.userData = {
                    isItem: true,
                    itemType: 'sword',
                    itemName: 'Steel Sword',
                    itemPrice: 25
                };
                scene.add(swordBlade);
                
                // Sword guard
                const swordGuardGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.1);
                const swordGuardMaterial = createStandardMaterial({
                    color: 0xDAA520,
                    roughness: 0.3,
                    metalness: 0.8
                });
                const swordGuard = new THREE.Mesh(swordGuardGeometry, swordGuardMaterial);
                swordGuard.position.set(6, 1.9, 2);
                scene.add(swordGuard);

                // Initialize interactions handler
                const gameInteractions = new GameInteractions({
                    shopkeeper: shopkeeperGroup,
                    scene: scene,
                    camera: camera
                });
                
                // Pass the user's address to the interactions handler
                gameInteractions.setUserAddress(address);
                
                // If we already have a preloaded greeting, store it directly in the interactions class
                if (window.preloadedShopkeeperGreeting) {
                    console.log('Found globally preloaded greeting, preparing to use it');
                    // No need to do anything special here, the getInitialGreeting method will check for it
                }
                
                // Setup raycaster for interactions
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                // Mouse position tracking for raycasting
                function onMouseMove(event) {
                    // Calculate mouse position in normalized device coordinates
                    // (-1 to +1) for both components
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                }
                
                function onClick(event) {
                    console.log('Click detected:', event.clientX, event.clientY);
                    
                    // Check if we clicked on a UI element
                    const clickedElement = document.elementFromPoint(event.clientX, event.clientY);
                    
                    // If clicked on UI element with pointer-events: auto, don't process the click for 3D scene
                    if (clickedElement && (
                        clickedElement.closest('#chat-window') || 
                        clickedElement.closest('#interaction-panel') ||
                        clickedElement.id === 'close-chat-btn' ||
                        clickedElement.id === 'chat-input' ||
                        clickedElement.id === 'chat-send-btn' ||
                        clickedElement.id === 'view-items-btn' ||
                        clickedElement.id === 'close-btn')) {
                        console.log('Click on UI element, bypassing 3D interaction');
                        return;
                    }
                    
                    // Update mouse position on click ensure accuracy
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                    
                    // Update the raycaster with the mouse position
                    raycaster.setFromCamera(mouse, camera);
                    
                    // Check for intersections with the scene
                    const intersects = raycaster.intersectObjects(scene.children, true);
                    console.log('Raycaster intersections:', intersects.length);
                    
                    if (intersects.length > 0) {
                        console.log('Hit object:', intersects[0].object.name || 'unnamed object');
                        
                        // Check if we clicked on the shopkeeper
                        let clickedOnShopkeeper = false;
                        let shopkeeperObject = null;
                        
                        // Check each intersection to see if it's part of the shopkeeper
                        for (let i = 0; i < intersects.length; i++) {
                            let obj = intersects[i].object;
                            let parent = obj.parent;
                            while (parent && !clickedOnShopkeeper) {
                                if (parent === shopkeeperGroup || obj === shopkeeperGroup) {
                                    clickedOnShopkeeper = true;
                                    shopkeeperObject = obj;
                                    break;
                                }
                                obj = parent;
                                parent = obj.parent;
                            }
                            if (clickedOnShopkeeper) break;
                        }
                        
                        if (clickedOnShopkeeper) {
                            console.log('Clicked on shopkeeper');
                            gameInteractions.startShopkeeperInteraction();
                            return;
                        }
                        
                        // Check if we clicked on an item
                        for (let i = 0; i < intersects.length; i++) {
                            const object = intersects[i].object;
                            if (object.userData && object.userData.isItem) {
                                console.log('Clicked on item:', object.userData.itemType);
                                gameInteractions.startItemInteraction(object.userData);
                                return;
                            }
                        }
                        
                        // If we clicked on the ground, handle ground click
                        const groundObjects = intersects.filter(i => i.object === street);
                        if (groundObjects.length > 0) {
                            const point = groundObjects[0].point;
                            console.log('Ground click at point:', point);
                            gameInteractions.handleGroundClick(point);
                        }
                    } else {
                        console.log('No object hit by raycaster');
                    }
                }
                
                // Attach the mouse event listeners to the renderer's DOM element
                console.log('Attaching mouse event listeners to renderer DOM element');
                renderer.domElement.addEventListener('click', onClick);
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                window.addEventListener('resize', onWindowResize);
                
                // Initialize game interactions
                console.log('Initializing game interactions');
                
                // Remove keyboard movement controls - they interfere with mouse controls
                // Instead, rely on OrbitControls for camera movement
                
                // Window resize handler
                function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
                
                // View items button - use our interaction handler
                document.getElementById('view-items-btn').addEventListener('click', function() {
                    gameInteractions.showShopItems();
                });
                
                // Close interaction panel button - use our interaction handler
                document.getElementById('close-btn').addEventListener('click', function() {
                    gameInteractions.closeInteraction();
                });
                
                // Buy buttons - delegate to our interaction handler
                document.querySelectorAll('.buy-btn').forEach(button => {
                    button.addEventListener('click', function() {
                        const itemElement = this.closest('.item');
                        const itemType = itemElement.dataset.item;
                        gameInteractions.buyItem(itemType);
                    });
                });

                // Animation loop
                function animate() {
                    // Request the next frame
                    requestAnimationFrame(animate);
                    
                    // Apply keyboard movement instead of OrbitControls
                    handleKeyboardMovement();
                    
                    // Update shopkeeper animation
                    shopkeeperTime += 0.01;
                    const sinValue = Math.sin(shopkeeperTime * 2) * 0.05;
                    shopkeeperGroup.position.y = 1 + sinValue;
                    shopkeeperGroup.rotation.y = Math.sin(shopkeeperTime) * 0.1;
                    
                    // Update crystal animation
                    crystal.rotation.y += 0.01;
                    crystal.position.y = 1.5 + Math.sin(Date.now() * 0.001) * 0.2;
                    
                    // Check distance to shopkeeper for chat proximity
                    const distanceToShopkeeper = calculateDistance(
                        { x: camera.position.x, y: 0, z: camera.position.z },
                        { x: shopkeeperGroup.position.x, y: 0, z: shopkeeperGroup.position.z }
                    );
                    
                    // Update speech bubble position
                    updateSpeechBubblePosition();
                    
                    // Chat proximity logic
                    const chatTriggerDistance = 8; 
                    const isNearShopkeeper = distanceToShopkeeper < chatTriggerDistance;
                    const chatWindow = document.getElementById('chat-window');
                    const speechBubble = document.getElementById('speech-bubble');
                    
                    if (isNearShopkeeper && !chatActive) {
                        speechBubble.textContent = `Hello ${address.toLowerCase().endsWith('.eth') ? address.split('.')[0] : "traveler"}! Come chat with me.`;
                        speechBubble.classList.add('active');
                        
                        if (!chatPromptTimeout) {
                            chatPromptTimeout = setTimeout(() => {
                                showChatPrompt();
                            }, 2000);
                        }
                    } else if (!isNearShopkeeper) {
                        speechBubble.classList.remove('active');
                        chatWindow.classList.remove('active');
                        clearTimeout(chatPromptTimeout);
                        chatPromptTimeout = null;
                        chatActive = false;
                        
                        if (conversationHistory.length > 0) {
                            conversationHistory = [];
                            console.log("Conversation reset - player walked away");
                        }
                    }
                    
                    // Render scene
                    renderer.render(scene, camera);
                }
                
                // Position the speech bubble above the shopkeeper's head
                function updateSpeechBubblePosition() {
                    // Convert shopkeeper position to screen coordinates
                    const shopkeeperHeadPosition = new THREE.Vector3(
                        shopkeeperGroup.position.x,
                        shopkeeperGroup.position.y + 2.2, // Above the head
                        shopkeeperGroup.position.z
                    );
                    
                    // Project the 3D position to 2D screen coordinates
                    shopkeeperHeadPosition.project(camera);
                    
                    // Convert to CSS coordinates
                    const x = (shopkeeperHeadPosition.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(shopkeeperHeadPosition.y * 0.5) + 0.5) * window.innerHeight;
                    
                    // Update speech bubble position
                    const speechBubble = document.getElementById('speech-bubble');
                    speechBubble.style.left = `${x}px`;
                    speechBubble.style.top = `${y}px`;
                }
                
                // Chat system variables
                let chatActive = false;
                let chatPromptTimeout = null;
                
                // LLM chat variables
                let conversationHistory = [];
                let isWaitingForResponse = false;
                
                // Configure API url - use ENV configuration or fallback to localhost
                const API_URL = window.ENV?.API_URL || 'http://localhost:3001/api';
                
                // System prompt for the shopkeeper character is now maintained on the server
                
                // Show chat prompt with greeting
                async function showChatPrompt() {
                    const chatWindow = document.getElementById('chat-window');
                    chatWindow.classList.remove('hidden');
                    chatWindow.classList.add('active');
                    chatActive = true;
                    
                    // Focus the input after a short delay to ensure the chat is visible
                    setTimeout(() => {
                        const chatInput = document.getElementById('chat-input');
                        chatInput.focus();
                    }, 300);
                    
                    // Show typing indicator while we get the initial greeting
                    const chatMessages = document.getElementById('chat-messages');
                    const indicator = document.createElement('div');
                    indicator.className = 'typing-indicator';
                    indicator.id = 'typing-indicator';
                    indicator.innerHTML = '<span></span><span></span><span></span>';
                    chatMessages.appendChild(indicator);
                    
                    try {
                        // Get personalized greeting from API
                        const initialGreeting = await gameInteractions.getInitialGreeting();
                        
                        // Remove typing indicator
                        const typingIndicator = document.getElementById('typing-indicator');
                        if (typingIndicator) {
                            typingIndicator.remove();
                        }
                        
                        // Add greeting to chat
                        addMessageToChat(initialGreeting, 'shopkeeper');
                        
                        // Add initial message to conversation history
                        conversationHistory.push({
                            role: "assistant", 
                            content: initialGreeting
                        });
                    } catch (error) {
                        console.error('Error getting initial greeting:', error);
                        
                        // Remove typing indicator
                        const typingIndicator = document.getElementById('typing-indicator');
                        if (typingIndicator) {
                            typingIndicator.remove();
                        }
                        
                        // Fallback to local greeting generation
                        const fallbackGreeting = generateShopkeeperGreeting();
                        addMessageToChat(fallbackGreeting, 'shopkeeper');
                        
                        // Add fallback greeting to conversation history
                        conversationHistory.push({
                            role: "assistant", 
                            content: fallbackGreeting
                        });
                    }
                }
                
                // Generate a personalized greeting based on user's wallet address
                // This is now just a fallback in case the API call fails
                function generateShopkeeperGreeting() {
                    const namePrefix = address.toLowerCase().endsWith('.eth') 
                        ? address.split('.')[0] 
                        : "honored guest";
                    
                    return `Ah, welcome to my humble shop, ${namePrefix}! *gestures broadly at the merchandise* please look around! I have the finest weapons and potions in all the land. That sword catching your eye?`;
                }
                
                // Add message to chat display
                function addMessageToChat(message, sender) {
                    const chatMessages = document.getElementById('chat-messages');
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `chat-message ${sender}-message`;
                    messageDiv.textContent = message;
                    chatMessages.appendChild(messageDiv);
                    
                    // Ensure smooth scrolling to the bottom of the chat when new messages are added
                    setTimeout(() => {
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }, 10);
                    
                    // Update speech bubble if it's a shopkeeper message
                    if (sender === 'shopkeeper') {
                        // Extract first sentence for speech bubble
                        const firstSentence = message.split(/[.!?]/)[0] + '.';
                        document.getElementById('speech-bubble').textContent = firstSentence;
                    }
                }
                
                // Show typing indicator
                function showTypingIndicator() {
                    const chatMessages = document.getElementById('chat-messages');
                    const indicator = document.createElement('div');
                    indicator.className = 'typing-indicator';
                    indicator.id = 'typing-indicator';
                    indicator.innerHTML = '<span></span><span></span><span></span>';
                    chatMessages.appendChild(indicator);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
                
                // Remove typing indicator
                function removeTypingIndicator() {
                    const indicator = document.getElementById('typing-indicator');
                    if (indicator) {
                        indicator.remove();
                    }
                }
                
                // Send message to LLM API and get response
                async function sendMessageToLLM(userMessage) {
                    // Show the typing indicator
                    showTypingIndicator();
                    
                    try {
                        // Create the messages array with conversation history
                        const messages = [
                            ...conversationHistory,
                            { role: "user", content: userMessage }
                        ];
                        
                        console.log("Sending to backend API:", messages);
                        
                        // Make the API call to our Node.js server
                        const response = await fetch(`${API_URL}/chat`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                messages: messages,
                                userAddress: address // Include the user's address
                                // System prompt is now managed on the server
                            })
                        });
                        
                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(`API Error: ${response.status} - ${errorData.error || response.statusText}`);
                        }
                        
                        // Parse the response from our backend
                        const data = await response.json();
                        const shopkeeperResponse = data.response;
                        
                        // Remove typing indicator and add response
                        removeTypingIndicator();
                        addMessageToChat(shopkeeperResponse, 'shopkeeper');
                        
                        // Add to conversation history
                        conversationHistory.push({ role: "user", content: userMessage });
                        conversationHistory.push({ role: "assistant", content: shopkeeperResponse });
                        
                        return shopkeeperResponse;
                    } catch (error) {
                        console.error("Error communicating with backend API:", error);
                        removeTypingIndicator();
                        
                        // If API call failed, fall back to the simulation
                        const fallbackResponse = simulateShopkeeperResponse(userMessage);
                        addMessageToChat(fallbackResponse, 'shopkeeper');
                        
                        // Add to conversation history
                        conversationHistory.push({ role: "user", content: userMessage });
                        conversationHistory.push({ role: "assistant", content: fallbackResponse });
                        
                        return fallbackResponse;
                    }
                }
                
                // This function simulates LLM responses for demo purposes
                // In production, replace this with actual API calls to an LLM service
                function simulateShopkeeperResponse(userMessage) {
                    const lowerMessage = userMessage.toLowerCase();
                    
                    if (lowerMessage.includes("sword") && lowerMessage.includes("price")) {
                        return "Ah, you have a keen eye for quality! *holds up the sword, letting light gleam off the blade* This magnificent sword? Normally 30 gold pieces, but for you, just 25! *leans in* The steel was forged in the mountain fires of Anatolia, folded one hundred times. You'll never find a finer blade this side of the great sea!";
                    }
                    else if (lowerMessage.includes("potion") || lowerMessage.includes("heal")) {
                        return "Healing potions? Of course! *pulls out a red vial* Only 5 gold pieces each. But... *glances at the sword on display* a warrior like yourself surely needs a proper weapon to prevent injuries in the first place, no? That sword would suit you perfectly! *smiles hopefully*";
                    }
                    else if (lowerMessage.includes("discount") || lowerMessage.includes("cheaper") || lowerMessage.includes("expensive")) {
                        return "*puts hand over heart, looking wounded* My friend, these prices? Already so reasonable! *sighs dramatically* But perhaps... for you, I could part with the sword for 22 gold pieces. *whispers* Don't tell my other customers - this is only because I see you are a person of great importance!";
                    }
                    else if (lowerMessage.includes("crystal") || lowerMessage.includes("magic")) {
                        return "*eyes light up* Ah! The magic crystal! *carefully takes it from its display* Feel the power humming within! 50 gold pieces for this rare treasure. It can enhance spells, reveal invisible enemies, or even guide you to hidden treasures! A bargain, I assure you!";
                    }
                    else if (lowerMessage.includes("hello") || lowerMessage.includes("hi") || lowerMessage.includes("greet")) {
                        return "Merhaba, welcome to my humble shop! *bows slightly* I am Kemal, purveyor of the finest weapons and magical items in the bazaar. *gestures to the sword display* That beauty caught your eye, yes? A warrior of your caliber deserves nothing less!";
                    }
                    else if (lowerMessage.includes("bye") || lowerMessage.includes("leaving") || lowerMessage.includes("go")) {
                        return "*looks disappointed* Leaving so soon? Wait! *hurriedly grabs the sword* For you, final offer - 20 gold pieces for this masterpiece! *places hand on heart* I lose money at this price, but I wish for you to remember Kemal's generosity! No? Perhaps next time then. Allah'a ısmarladık, my friend!";
                    }
                    else {
                        return "*nods enthusiastically* Yes, yes! But have you considered this magnificent sword? *lifts it carefully from the display* Feel the balance! See how the light dances on the blade! For a mere 25 gold pieces, you could be the envy of all your friends. Shall I wrap it for you? *smiles hopefully*";
                    }
                }
                
                // Show notification message
                function showNotification(message) {
                    const notification = document.createElement('div');
                    notification.className = 'notification';
                    notification.textContent = message;
                    
                    document.body.appendChild(notification);
                    
                    setTimeout(() => {
                        notification.classList.add('fade-out');
                        setTimeout(() => {
                            notification.remove();
                        }, 500);
                    }, 2000);
                }

                // Setup chat input and send button
                function setupChatInputHandlers() {
                    const chatInput = document.getElementById('chat-input');
                    const sendButton = document.getElementById('chat-send-btn');
                    const chatMessages = document.getElementById('chat-messages');
                    const chatWindow = document.getElementById('chat-window');
                    
                    // When chat input gets focus, prevent keyboard controls from working
                    chatInput.addEventListener('focus', function() {
                        console.log('Chat input focused - disabling keyboard movement');
                    });
                    
                    chatInput.addEventListener('blur', function() {
                        console.log('Chat input blurred - enabling keyboard movement');
                    });
                    
                    // Force focus when clicking on the chat input
                    chatInput.addEventListener('click', function(event) {
                        event.stopPropagation();
                        this.focus();
                    });
                    
                    // Improved scrolling for chat messages
                    chatMessages.addEventListener('wheel', function(event) {
                        event.stopPropagation();
                        console.log('Wheel event in chat messages');
                    }, { passive: false });
                    
                    // Ensure mouse events on chat messages don't affect the 3D scene
                    chatMessages.addEventListener('mousedown', function(event) {
                        event.stopPropagation();
                        console.log('Mouse down in chat messages');
                    }, true);
                    
                    chatMessages.addEventListener('mousemove', function(event) {
                        event.stopPropagation();
                    }, true);
                    
                    chatMessages.addEventListener('mouseup', function(event) {
                        event.stopPropagation();
                    }, true);
                    
                    // Send message on button click
                    sendButton.addEventListener('click', function(event) {
                        event.stopPropagation();
                        sendUserMessage();
                    });
                    
                    // Send message on Enter key
                    chatInput.addEventListener('keypress', function(event) {
                        if (event.key === 'Enter') {
                            sendUserMessage();
                        }
                    });
                    
                    function sendUserMessage() {
                        if (isWaitingForResponse) return;
                        
                        const userMessage = chatInput.value.trim();
                        if (userMessage === '') return;
                        
                        // Add user message to chat
                        addMessageToChat(userMessage, 'player');
                        
                        // Clear input field
                        chatInput.value = '';
                        
                        // Set waiting flag
                        isWaitingForResponse = true;
                        
                        // Get shopkeeper response
                        sendMessageToLLM(userMessage).then(() => {
                            isWaitingForResponse = false;
                        });
                    }
                    
                    // Setup the close button with proper event handling
                    const closeButton = document.getElementById('close-chat-btn');
                    if (closeButton) {
                        // Remove existing listeners and create a fresh button
                        const newCloseButton = closeButton.cloneNode(true);
                        closeButton.parentNode.replaceChild(newCloseButton, closeButton);
                        
                        // Add click listener that properly captures events
                        newCloseButton.addEventListener('click', function(event) {
                            // Make sure this click doesn't go to other elements
                            event.stopPropagation();
                            event.preventDefault();
                            
                            console.log('Close chat button clicked');
                            chatWindow.classList.remove('active');
                            setTimeout(() => {
                                chatWindow.classList.add('hidden');
                                chatActive = false;
                            }, 300);
                        });
                    }
                }
                
                // Initialize chat system with access to the user's address
                setupChatInputHandlers();
                
                // Hide loading message now that everything is ready
                document.getElementById('loading').style.display = 'none';
                
                // Start the animation loop
                animate();
                
                // Show success message
                showNotification('Scene loaded successfully!');
                
            } catch (error) {
                console.error('Error initializing Three.js scene:', error);
                document.getElementById('loading').innerHTML = 'Error: ' + error.message;
            }
        }
    </script>
</body>
</html> 