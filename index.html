<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Village Shopkeeper</title>
    
    <!-- Load Three.js from more reliable CDN sources -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Embed our own OrbitControls implementation -->
    <script>
        // Simple OrbitControls implementation that doesn't rely on external dependencies
        // Based on the Three.js OrbitControls but simplified for our needs
        (function() {
            // Create OrbitControls constructor
            THREE.OrbitControls = function(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement || document.createElement('div');
                this.enabled = true;
                
                // API
                this.enableDamping = false;
                this.dampingFactor = 0.05;
                this.enableZoom = true;
                this.zoomSpeed = 1.0;
                this.enableRotate = true;
                this.rotateSpeed = 1.0;
                this.enablePan = true;
                this.panSpeed = 1.0;
                this.minDistance = 0;
                this.maxDistance = Infinity;
                this.minPolarAngle = 0; // radians
                this.maxPolarAngle = Math.PI; // radians
                
                // Internals
                var scope = this;
                var rotateStart = new THREE.Vector2();
                var rotateEnd = new THREE.Vector2();
                var rotateDelta = new THREE.Vector2();
                var panStart = new THREE.Vector2();
                var panEnd = new THREE.Vector2();
                var panDelta = new THREE.Vector2();
                var dollyStart = new THREE.Vector2();
                var dollyEnd = new THREE.Vector2();
                var dollyDelta = new THREE.Vector2();
                
                var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2 };
                var state = STATE.NONE;
                
                var spherical = new THREE.Spherical();
                var sphericalDelta = new THREE.Spherical();
                var scale = 1;
                var panOffset = new THREE.Vector3();
                var zoomChanged = false;
                var rotateChanged = false;
                
                // Event handlers
                function onMouseDown(event) {
                    if (!scope.enabled) return;
                    
                    event.preventDefault();
                    
                    if (event.button === 0) {
                        state = STATE.ROTATE;
                        rotateStart.set(event.clientX, event.clientY);
                    } else if (event.button === 1) {
                        state = STATE.DOLLY;
                        dollyStart.set(event.clientX, event.clientY);
                    } else if (event.button === 2) {
                        state = STATE.PAN;
                        panStart.set(event.clientX, event.clientY);
                    }
                    
                    scope.domElement.addEventListener('mousemove', onMouseMove, false);
                    scope.domElement.addEventListener('mouseup', onMouseUp, false);
                }
                
                function onMouseMove(event) {
                    if (!scope.enabled) return;
                    
                    event.preventDefault();
                    
                    if (state === STATE.ROTATE) {
                        rotateEnd.set(event.clientX, event.clientY);
                        rotateDelta.subVectors(rotateEnd, rotateStart);
                        
                        // Rotating across the X axis (up/down)
                        sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / scope.domElement.clientHeight * scope.rotateSpeed;
                        
                        // Rotating across the Y axis (left/right)
                        sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / scope.domElement.clientWidth * scope.rotateSpeed;
                        
                        rotateStart.copy(rotateEnd);
                        rotateChanged = true;
                    } else if (state === STATE.DOLLY) {
                        dollyEnd.set(event.clientX, event.clientY);
                        dollyDelta.subVectors(dollyEnd, dollyStart);
                        
                        if (dollyDelta.y > 0) {
                            scale /= 1.1;
                        } else if (dollyDelta.y < 0) {
                            scale *= 1.1;
                        }
                        
                        dollyStart.copy(dollyEnd);
                        zoomChanged = true;
                    } else if (state === STATE.PAN) {
                        panEnd.set(event.clientX, event.clientY);
                        panDelta.subVectors(panEnd, panStart);
                        
                        pan(panDelta.x, panDelta.y);
                        
                        panStart.copy(panEnd);
                    }
                    
                    scope.update();
                }
                
                function onMouseUp() {
                    scope.domElement.removeEventListener('mousemove', onMouseMove, false);
                    scope.domElement.removeEventListener('mouseup', onMouseUp, false);
                    state = STATE.NONE;
                }
                
                function onMouseWheel(event) {
                    if (!scope.enabled || !scope.enableZoom) return;
                    
                    event.preventDefault();
                    
                    if (event.deltaY < 0) {
                        scale /= 1.1;
                    } else {
                        scale *= 1.1;
                    }
                    
                    zoomChanged = true;
                    scope.update();
                }
                
                function pan(deltaX, deltaY) {
                    var offset = new THREE.Vector3();
                    var element = scope.domElement;
                    
                    // Calculate camera's local coordinate system
                    var position = scope.camera.position;
                    offset.copy(position).sub(scope.target);
                    var targetDistance = offset.length();
                    
                    // Convert deltas from pixels to world space
                    // Half of the FOV is center to top of screen
                    targetDistance *= Math.tan((scope.camera.fov / 2) * Math.PI / 180.0);
                    
                    // Set the panning distance based on viewport size
                    // We need to use the width and height of the viewport which can depend on camera's aspect ratio
                    // For simplicity, we'll just use a rough approximation
                    var panX = 2 * deltaX * targetDistance / element.clientWidth;
                    var panY = 2 * deltaY * targetDistance / element.clientHeight;
                    
                    // Find right and up vectors for camera
                    var upVector = new THREE.Vector3(0, 1, 0);
                    var rightVector = new THREE.Vector3();
                    rightVector.crossVectors(scope.camera.up, offset.normalize()).normalize();
                    
                    // Move in the right and up directions
                    panOffset.x -= panX * scope.panSpeed * rightVector.x;
                    panOffset.y -= panY * scope.panSpeed * upVector.y;
                    panOffset.z -= panX * scope.panSpeed * rightVector.z;
                }
                
                // Set up initial state
                this.target = new THREE.Vector3();
                this.update = function() {
                    var offset = new THREE.Vector3();
                    
                    // Get current position
                    var position = scope.camera.position;
                    offset.copy(position).sub(scope.target);
                    
                    // Convert to spherical coordinates
                    spherical.setFromVector3(offset);
                    
                    // Apply rotation changes
                    spherical.theta += sphericalDelta.theta;
                    spherical.phi += sphericalDelta.phi;
                    
                    // Restrict phi to be between the min and max
                    spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                    spherical.makeSafe();
                    
                    // Apply zoom (dolly)
                    spherical.radius *= scale;
                    spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                    
                    // Apply pan
                    scope.target.add(panOffset);
                    
                    // Convert back to cartesian coordinates
                    offset.setFromSpherical(spherical);
                    
                    // Update camera position
                    position.copy(scope.target).add(offset);
                    scope.camera.lookAt(scope.target);
                    
                    // Reset changes
                    sphericalDelta.set(0, 0, 0);
                    panOffset.set(0, 0, 0);
                    scale = 1;
                    
                    // Return true if the update made any changes
                    return zoomChanged || rotateChanged;
                };
                
                // Set up event listeners
                this.domElement.addEventListener('contextmenu', function(event) { event.preventDefault(); }, false);
                this.domElement.addEventListener('mousedown', onMouseDown, false);
                this.domElement.addEventListener('wheel', onMouseWheel, false);
                
                // Initial update
                this.update();
                
                // For console logging
                console.log('Custom OrbitControls created successfully');
            };
        })();
    </script>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(51, 25, 0, 0.85);
            color: #FFD700;
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid #8B4513;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        
        .fade-out {
            opacity: 0;
        }
        
        #ui-container {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #interaction-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(51, 25, 0, 0.9);
            color: #FFD700;
            padding: 20px;
            border-radius: 10px;
            border: 3px solid #8B4513;
            width: 300px;
            pointer-events: auto;
        }
        
        .hidden {
            display: none;
        }
        
        #shop-items {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .item {
            width: 45%;
            background-color: rgba(139, 69, 19, 0.5);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .item-image {
            width: 50px;
            height: 50px;
            margin: 0 auto 10px;
            border-radius: 50%;
        }
        
        .potion-img {
            background-color: #FF0000;
        }
        
        .sword-img {
            background-color: #C0C0C0;
        }
        
        button {
            background-color: #8B4513;
            color: #FFD700;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            font-weight: bold;
        }
        
        button:hover {
            background-color: #A0522D;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
        
        /* Chat window styles */
        #chat-window {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 350px;
            background-color: rgba(51, 25, 0, 0.9);
            color: #FFD700;
            border-radius: 10px;
            border: 3px solid #8B4513;
            pointer-events: auto;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateY(20px);
            opacity: 0;
            overflow: hidden;
            max-height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        #chat-window.active {
            transform: translateY(0);
            opacity: 1;
        }
        
        #chat-header {
            background-color: rgba(139, 69, 19, 0.8);
            padding: 10px;
            border-radius: 7px 7px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #chat-messages {
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
        }
        
        .shopkeeper-message {
            background-color: rgba(139, 69, 19, 0.5);
            align-self: flex-start;
            border-bottom-left-radius: 0;
        }
        
        .player-message {
            background-color: rgba(25, 70, 120, 0.5);
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }
        
        #chat-options {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .chat-option {
            background-color: rgba(139, 69, 19, 0.5);
            color: #FFD700;
            border: 1px solid #8B4513;
            border-radius: 8px;
            padding: 8px;
            text-align: left;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .chat-option:hover {
            background-color: rgba(139, 69, 19, 0.8);
        }
        
        /* Speech bubble over shopkeeper's head */
        #speech-bubble {
            position: absolute;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            color: #333;
            font-size: 14px;
            max-width: 200px;
            text-align: center;
            pointer-events: none;
            transform: translate(-50%, -120%);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }
        
        #speech-bubble:after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.9) transparent transparent;
        }
        
        #speech-bubble.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui-container">
        <div id="interaction-panel" class="hidden">
            <h3>Shopkeeper</h3>
            <p id="dialog-text">Greetings traveler! Would you like to see my wares?</p>
            <div id="shop-items" class="hidden">
                <div class="item" data-item="potion">
                    <div class="item-image potion-img"></div>
                    <div class="item-name">Healing Potion</div>
                    <div class="item-price">5 coins</div>
                    <button class="buy-btn">Buy</button>
                </div>
                <div class="item" data-item="sword">
                    <div class="item-image sword-img"></div>
                    <div class="item-name">Steel Sword</div>
                    <div class="item-price">25 coins</div>
                    <button class="buy-btn">Buy</button>
                </div>
            </div>
            <button id="view-items-btn">View Items</button>
            <button id="close-btn">Close</button>
        </div>

        <!-- Chat window -->
        <div id="chat-window" class="hidden">
            <div id="chat-header">
                <h3>Talking with Shopkeeper</h3>
                <button id="close-chat-btn" style="background: none; border: none; color: #FFD700; cursor: pointer;">✕</button>
            </div>
            <div id="chat-messages">
                <!-- Chat messages will be added here -->
            </div>
            <div id="chat-options">
                <!-- Chat options will be added here -->
            </div>
        </div>
        
        <!-- Speech bubble above shopkeeper -->
        <div id="speech-bubble"></div>
    </div>

    <div id="instructions">
        <h3>Controls:</h3>
        <p>Move: WASD or Arrow Keys</p>
        <p>Interact: E or Click on objects</p>
        <p>Camera: Click and drag to rotate, scroll to zoom</p>
    </div>

    <div id="loading">Loading Three.js...</div>

    <script>
        // Start initialization when everything is loaded
        window.onload = function() {
            // Check if Three.js is loaded
            if (typeof THREE === 'undefined') {
                console.error('THREE is not defined! The Three.js library failed to load.');
                document.getElementById('loading').innerHTML = 'Error loading Three.js!<br>Please check your internet connection and try again.';
                return;
            }
            
            console.log('THREE is loaded successfully!');
            
            // Check if our custom OrbitControls is available
            if (typeof THREE.OrbitControls !== 'function') {
                console.error('OrbitControls is not defined!');
                document.getElementById('loading').innerHTML = 'Error: OrbitControls not available';
                return;
            }
            
            console.log('OrbitControls is available!');
            // Initialize the scene
            initializeScene();
        };
        
        // Main scene initialization function
        function initializeScene() {
            // Hide loading message
            document.getElementById('loading').style.display = 'none';
            
            // Utility functions
            function calculateDistance(point1, point2) {
                return Math.sqrt(
                    Math.pow(point2.x - point1.x, 2) + 
                    Math.pow(point2.y - point1.y, 2) + 
                    Math.pow(point2.z - point1.z, 2)
                );
            }

            function toggleElement(elementId, show) {
                const element = document.getElementById(elementId);
                if (show) {
                    element.classList.remove('hidden');
                } else {
                    element.classList.add('hidden');
                }
            }

            function createStandardMaterial(parameters = {}) {
                const {
                    color = 0xffffff,
                    roughness = 0.5,
                    metalness = 0.5,
                    map = null,
                    transparent = false,
                    opacity = 1.0,
                    emissive = 0x000000,
                    emissiveIntensity = 0,
                    side = THREE.FrontSide
                } = parameters;

                return new THREE.MeshStandardMaterial({
                    color,
                    roughness,
                    metalness,
                    map,
                    transparent,
                    opacity,
                    emissive,
                    emissiveIntensity,
                    side
                });
            }

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            try {
                console.log('Starting Three.js setup');
                
                // Scene setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue background
                
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                
                console.log('Creating renderer');
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(renderer.domElement);
                
                // Position camera to better view the shop and shopkeeper
                camera.position.set(0, 8, 15);
                camera.lookAt(5, 2, 5); // Look directly at the shop area
                
                // Add orbit controls
                console.log('Setting up OrbitControls');
                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
                controls.maxPolarAngle = Math.PI / 2;
                // Set target to the shop's position so orbit controls rotate around it
                controls.target.set(5, 2, 5);
                controls.update();
                
                // Setup lighting
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Brighter ambient light
                scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Brighter directional light
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                
                // Configure shadow properties
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;
                
                scene.add(directionalLight);
                
                // Point light for the shop - make it brighter
                const shopLight = new THREE.PointLight(0xf5c542, 1.5, 20);
                shopLight.position.set(5, 5, 5);
                shopLight.castShadow = true;
                scene.add(shopLight);
                
                // Add a helper to visualize the shop position
                const axesHelper = new THREE.AxesHelper(3);
                axesHelper.position.set(5, 0.5, 5);
                scene.add(axesHelper);

                // Create ground/street
                const streetGeometry = new THREE.PlaneGeometry(50, 50);
                const streetMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xaaaaaa,
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                const street = new THREE.Mesh(streetGeometry, streetMaterial);
                street.rotation.x = -Math.PI / 2;
                street.receiveShadow = true;
                scene.add(street);
                
                // Add street details
                for (let i = 0; i < 150; i++) {
                    const size = randomInRange(0.2, 0.8);
                    const posX = randomInRange(-25, 25);
                    const posZ = randomInRange(-25, 25);
                    
                    const stoneGeometry = new THREE.BoxGeometry(size, 0.05, size);
                    const stoneMaterial = new THREE.MeshStandardMaterial({
                        color: randomInRange(0x888888, 0xaaaaaa),
                        roughness: 1.0
                    });
                    
                    const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                    stone.position.set(posX, 0.025, posZ);
                    stone.receiveShadow = true;
                    
                    scene.add(stone);
                }
                
                // Create shop with wooden structure as seen in the concept art
                const shopGroup = new THREE.Group();
                shopGroup.position.set(5, 0, 5);
                
                console.log('Creating shop at position:', shopGroup.position);
                
                // Shop base/floor
                const baseGeometry = new THREE.BoxGeometry(8, 0.5, 6);
                const baseMaterial = createStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.8
                });
                const shopBase = new THREE.Mesh(baseGeometry, baseMaterial);
                shopBase.position.y = 0.25;
                shopBase.castShadow = true;
                shopBase.receiveShadow = true;
                shopGroup.add(shopBase);
                
                // Shop walls
                const wallMaterial = createStandardMaterial({ 
                    color: 0xA0522D,
                    roughness: 0.7
                });
                
                // Back wall
                const backWallGeometry = new THREE.BoxGeometry(8, 3, 0.3);
                const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
                backWall.position.set(0, 2, -3);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                shopGroup.add(backWall);
                
                // Side walls
                const sideWallGeometry = new THREE.BoxGeometry(0.3, 3, 6);
                
                const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
                leftWall.position.set(-4, 2, 0);
                leftWall.castShadow = true;
                leftWall.receiveShadow = true;
                shopGroup.add(leftWall);
                
                const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
                rightWall.position.set(4, 2, 0);
                rightWall.castShadow = true;
                rightWall.receiveShadow = true;
                shopGroup.add(rightWall);
                
                // Counter
                const counterGeometry = new THREE.BoxGeometry(7, 1.2, 1.5);
                const counterMaterial = createStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.6
                });
                const counter = new THREE.Mesh(counterGeometry, counterMaterial);
                counter.position.set(0, 1.1, 2);
                counter.castShadow = true;
                counter.receiveShadow = true;
                shopGroup.add(counter);
                
                // Awning/canopy
                const canopyGeometry = new THREE.BoxGeometry(8, 0.1, 3);
                const canopyMaterial = createStandardMaterial({ 
                    color: 0xFF6347, // Red striped awning as in concept
                    roughness: 0.5
                });
                const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                canopy.position.set(0, 3.5, 1);
                canopy.castShadow = true;
                shopGroup.add(canopy);
                
                // Canopy supports
                const supportGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
                const supportMaterial = createStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.7
                });
                
                const leftSupport = new THREE.Mesh(supportGeometry, supportMaterial);
                leftSupport.position.set(-3.5, 3.2, 2.5);
                shopGroup.add(leftSupport);
                
                const rightSupport = new THREE.Mesh(supportGeometry, supportMaterial);
                rightSupport.position.set(3.5, 3.2, 2.5);
                shopGroup.add(rightSupport);
                
                // Create shelves for potions
                const shelfMaterial = createStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.7
                });
                
                // Create three shelves
                for (let i = 0; i < 3; i++) {
                    const shelfGeometry = new THREE.BoxGeometry(6, 0.2, 1);
                    const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
                    shelf.position.set(0, 1.5 + i * 0.8, -2.5);
                    shelf.castShadow = true;
                    shelf.receiveShadow = true;
                    shopGroup.add(shelf);
                    
                    // Add potion bottles to shelves
                    for (let j = 0; j < 5; j++) {
                        const potionGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 8);
                        const potionMaterial = createStandardMaterial({
                            color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                            transparent: true,
                            opacity: 0.8,
                            emissive: 0x555555,
                            emissiveIntensity: 0.2
                        });
                        const potion = new THREE.Mesh(potionGeometry, potionMaterial);
                        potion.position.set(-2.5 + j * 1.25, 1.65 + i * 0.8, -2.5);
                        shopGroup.add(potion);
                    }
                }
                
                // Add swords mounted on the back wall
                for (let i = 0; i < 3; i++) {
                    // Sword handle
                    const handleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
                    const handleMaterial = createStandardMaterial({
                        color: 0x8B4513,
                        roughness: 0.7
                    });
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    handle.position.set(-2 + i * 2, 2, -2.8);
                    handle.rotation.x = Math.PI / 2;
                    shopGroup.add(handle);
                    
                    // Sword blade
                    const bladeGeometry = new THREE.BoxGeometry(0.2, 0.05, 1.2);
                    const bladeMaterial = createStandardMaterial({
                        color: 0xC0C0C0,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    blade.position.set(-2 + i * 2, 2, -2.2);
                    shopGroup.add(blade);
                    
                    // Sword guard
                    const guardGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.1);
                    const guardMaterial = createStandardMaterial({
                        color: 0xDAA520,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    const guard = new THREE.Mesh(guardGeometry, guardMaterial);
                    guard.position.set(-2 + i * 2, 2, -2.8);
                    shopGroup.add(guard);
                }
                
                scene.add(shopGroup);
                
                // Create the shopkeeper
                const shopkeeperGroup = new THREE.Group();
                shopkeeperGroup.position.set(5, 1, 3.5); // Moved forward a bit to be more visible
                
                console.log('Creating shopkeeper at position:', shopkeeperGroup.position);
                
                // Create the head
                const headGeometry = new THREE.SphereGeometry(0.3, 32, 32);
                const headMaterial = createStandardMaterial({
                    color: 0xF5DEB3, // Skin tone
                    roughness: 0.7
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.8;
                shopkeeperGroup.add(head);
                
                // Create the body/torso
                const torsoGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.8, 8);
                const torsoMaterial = createStandardMaterial({
                    color: 0x8B4513, // Brown for clothing
                    roughness: 0.8
                });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 1.3;
                shopkeeperGroup.add(torso);
                
                // Create the beard (as seen in concept art)
                const beardGeometry = new THREE.ConeGeometry(0.25, 0.4, 8);
                const beardMaterial = createStandardMaterial({
                    color: 0x4A412A, // Dark brown
                    roughness: 1.0
                });
                const beard = new THREE.Mesh(beardGeometry, beardMaterial);
                beard.position.set(0, 1.6, 0.15);
                beard.rotation.x = Math.PI / 3; // Angle the beard
                shopkeeperGroup.add(beard);
                
                // Create eyes
                const eyeGeometry = new THREE.SphereGeometry(0.05, 16, 16);
                const eyeMaterial = createStandardMaterial({
                    color: 0x000000, // Black
                    roughness: 0.5
                });
                
                // Left eye
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.1, 1.85, 0.25);
                shopkeeperGroup.add(leftEye);
                
                // Right eye
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.1, 1.85, 0.25);
                shopkeeperGroup.add(rightEye);
                
                // Add arms to shopkeeper
                const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 8);
                const armMaterial = createStandardMaterial({
                    color: 0x8B4513, // Brown for clothing
                    roughness: 0.8
                });
                
                // Left arm
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.4, 1.3, 0);
                leftArm.rotation.z = -0.3;
                shopkeeperGroup.add(leftArm);
                
                // Right arm
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.4, 1.3, 0);
                rightArm.rotation.z = 0.3;
                shopkeeperGroup.add(rightArm);
                
                // Set up shadow casting for all parts
                shopkeeperGroup.traverse(function(object) {
                    if (object.isMesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });
                
                // Create a simple bobbing animation for the shopkeeper
                let shopkeeperTime = 0;
                
                // Add shopkeeper to scene
                scene.add(shopkeeperGroup);
                
                // Create floating crystal (similar to the blue gem in concept)
                const crystalGeometry = new THREE.OctahedronGeometry(0.5, 0);
                const crystalMaterial = createStandardMaterial({
                    color: 0x00BFFF,
                    transparent: true,
                    opacity: 0.7,
                    emissive: 0x00BFFF,
                    emissiveIntensity: 0.5
                });
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(5, 1.5, 2); // Raised height for visibility
                crystal.userData = {
                    isItem: true,
                    itemType: 'crystal',
                    itemName: 'Magic Crystal',
                    itemPrice: 50
                };
                scene.add(crystal);
                
                // Create items on the counter
                // Health potion
                const potionGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.4, 8);
                const potionMaterial = createStandardMaterial({
                    color: 0xFF0000, // Red for health potion
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.3
                });
                const potion = new THREE.Mesh(potionGeometry, potionMaterial);
                potion.position.set(4, 1.9, 2);
                potion.userData = {
                    isItem: true,
                    itemType: 'potion',
                    itemName: 'Health Potion',
                    itemPrice: 5
                };
                scene.add(potion);
                
                // Sword for sale on counter
                // Sword handle
                const swordHandleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
                const swordHandleMaterial = createStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.7
                });
                const swordHandle = new THREE.Mesh(swordHandleGeometry, swordHandleMaterial);
                swordHandle.position.set(6, 1.9, 2);
                swordHandle.rotation.x = Math.PI / 2;
                scene.add(swordHandle);
                
                // Sword blade
                const swordBladeGeometry = new THREE.BoxGeometry(0.2, 0.05, 1.2);
                const swordBladeMaterial = createStandardMaterial({
                    color: 0xC0C0C0,
                    roughness: 0.3,
                    metalness: 0.8
                });
                const swordBlade = new THREE.Mesh(swordBladeGeometry, swordBladeMaterial);
                swordBlade.position.set(6, 1.9, 1.4);
                swordBlade.userData = {
                    isItem: true,
                    itemType: 'sword',
                    itemName: 'Steel Sword',
                    itemPrice: 25
                };
                scene.add(swordBlade);
                
                // Sword guard
                const swordGuardGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.1);
                const swordGuardMaterial = createStandardMaterial({
                    color: 0xDAA520,
                    roughness: 0.3,
                    metalness: 0.8
                });
                const swordGuard = new THREE.Mesh(swordGuardGeometry, swordGuardMaterial);
                swordGuard.position.set(6, 1.9, 2);
                scene.add(swordGuard);

                // Setup raycaster for interactions
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                // Mouse movement handler
                function onMouseMove(event) {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                }
                
                // Click handler
                function onClick(event) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(scene.children, true);
                    
                    if (intersects.length > 0) {
                        // Check if we clicked on the shopkeeper
                        const clickedObject = intersects[0].object;
                        
                        // Find the top-level parent
                        let currentObj = clickedObject;
                        while (currentObj.parent && currentObj.parent !== scene) {
                            currentObj = currentObj.parent;
                        }
                        
                        if (currentObj === shopkeeperGroup) {
                            // Show interaction panel
                            toggleElement('interaction-panel', true);
                        }
                    }
                }
                
                // Event listeners
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('click', onClick);
                window.addEventListener('resize', onWindowResize);
                
                // View items button
                document.getElementById('view-items-btn').addEventListener('click', function() {
                    toggleElement('shop-items', true);
                    document.getElementById('dialog-text').textContent = 
                        `You have 100 coins. What would you like to buy?`;
                });
                
                // Close interaction panel button
                document.getElementById('close-btn').addEventListener('click', function() {
                    toggleElement('interaction-panel', false);
                    toggleElement('shop-items', false);
                });
                
                // Buy buttons
                document.querySelectorAll('.buy-btn').forEach(button => {
                    button.addEventListener('click', function() {
                        const itemElement = this.closest('.item');
                        const itemType = itemElement.dataset.item;
                        const itemName = itemElement.querySelector('.item-name').textContent;
                        const itemPrice = parseInt(itemElement.querySelector('.item-price').textContent);
                        
                        showNotification(`Purchased ${itemName}!`);
                    });
                });
                
                // Window resize handler
                function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
                
                // Show notification message
                function showNotification(message) {
                    const notification = document.createElement('div');
                    notification.className = 'notification';
                    notification.textContent = message;
                    
                    document.body.appendChild(notification);
                    
                    setTimeout(() => {
                        notification.classList.add('fade-out');
                        setTimeout(() => {
                            notification.remove();
                        }, 500);
                    }, 2000);
                }
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    // Update controls
                    controls.update();
                    
                    // Update shopkeeper animation
                    shopkeeperTime += 0.01;
                    const sinValue = Math.sin(shopkeeperTime * 2) * 0.05;
                    shopkeeperGroup.position.y = 1 + sinValue;
                    shopkeeperGroup.rotation.y = Math.sin(shopkeeperTime) * 0.1;
                    
                    // Update crystal animation
                    crystal.rotation.y += 0.01;
                    crystal.position.y = 1.5 + Math.sin(Date.now() * 0.001) * 0.2;
                    
                    // Check distance to shopkeeper for chat proximity
                    const distanceToShopkeeper = calculateDistance(
                        { x: camera.position.x, y: 0, z: camera.position.z },
                        { x: shopkeeperGroup.position.x, y: 0, z: shopkeeperGroup.position.z }
                    );
                    
                    // Update speech bubble position
                    updateSpeechBubblePosition();
                    
                    // Check if player is close enough to shopkeeper to trigger chat
                    const chatTriggerDistance = 8; // Distance to trigger chat
                    const isNearShopkeeper = distanceToShopkeeper < chatTriggerDistance;
                    
                    // Get chat window element
                    const chatWindow = document.getElementById('chat-window');
                    const speechBubble = document.getElementById('speech-bubble');
                    
                    // Show or hide chat based on proximity
                    if (isNearShopkeeper && !chatActive) {
                        // Only show speech bubble initially
                        speechBubble.textContent = "Hello traveler! Come chat with me.";
                        speechBubble.classList.add('active');
                        
                        // Add a small delay before showing chat prompt
                        if (!chatPromptTimeout) {
                            chatPromptTimeout = setTimeout(() => {
                                showChatPrompt();
                            }, 2000);
                        }
                    } else if (!isNearShopkeeper) {
                        speechBubble.classList.remove('active');
                        chatWindow.classList.remove('active');
                        clearTimeout(chatPromptTimeout);
                        chatPromptTimeout = null;
                        chatActive = false;
                    }
                    
                    // Render scene
                    renderer.render(scene, camera);
                }
                
                // Position the speech bubble above the shopkeeper's head
                function updateSpeechBubblePosition() {
                    // Convert shopkeeper position to screen coordinates
                    const shopkeeperHeadPosition = new THREE.Vector3(
                        shopkeeperGroup.position.x,
                        shopkeeperGroup.position.y + 2.2, // Above the head
                        shopkeeperGroup.position.z
                    );
                    
                    // Project the 3D position to 2D screen coordinates
                    shopkeeperHeadPosition.project(camera);
                    
                    // Convert to CSS coordinates
                    const x = (shopkeeperHeadPosition.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(shopkeeperHeadPosition.y * 0.5) + 0.5) * window.innerHeight;
                    
                    // Update speech bubble position
                    const speechBubble = document.getElementById('speech-bubble');
                    speechBubble.style.left = `${x}px`;
                    speechBubble.style.top = `${y}px`;
                }
                
                // Chat system variables
                let chatActive = false;
                let chatPromptTimeout = null;
                let currentDialogueStep = 'greeting';
                
                // Dialogue options for the shopkeeper
                const dialogueTree = {
                    greeting: {
                        shopkeeperMessage: "Greetings, traveler! What brings you to my humble shop today?",
                        options: [
                            { text: "I'm looking for weapons.", nextStep: "weapons" },
                            { text: "Do you have any potions?", nextStep: "potions" },
                            { text: "Tell me about yourself.", nextStep: "about" },
                            { text: "Just browsing, thanks.", nextStep: "browsing" }
                        ]
                    },
                    weapons: {
                        shopkeeperMessage: "Ah, weapons! I have the finest steel in the region. My swords are forged in the ancient fires of the mountain dwarves.",
                        options: [
                            { text: "How much for that steel sword?", nextStep: "sword_price" },
                            { text: "Do you have anything magical?", nextStep: "magical_weapons" },
                            { text: "Let me see what else you have.", nextStep: "greeting" }
                        ]
                    },
                    potions: {
                        shopkeeperMessage: "I have healing potions, strength elixirs, and even rare invisibility draughts. What sort of remedy do you seek?",
                        options: [
                            { text: "I need something for healing.", nextStep: "healing_potions" },
                            { text: "What's your strongest potion?", nextStep: "strong_potion" },
                            { text: "Let me see what else you have.", nextStep: "greeting" }
                        ]
                    },
                    about: {
                        shopkeeperMessage: "I've been a shopkeeper in this village for over 30 years. Before that, I was an adventurer like yourself, until I took an arrow to the knee.",
                        options: [
                            { text: "Tell me about your adventures.", nextStep: "adventures" },
                            { text: "How's business these days?", nextStep: "business" },
                            { text: "Let's talk about your wares.", nextStep: "greeting" }
                        ]
                    },
                    browsing: {
                        shopkeeperMessage: "Take your time! Let me know if anything catches your eye. I've got special discounts for polite travelers.",
                        options: [
                            { text: "Actually, I do have questions about your weapons.", nextStep: "weapons" },
                            { text: "Tell me about your potions.", nextStep: "potions" },
                            { text: "I'd like to buy something.", nextStep: "buy" }
                        ]
                    },
                    sword_price: {
                        shopkeeperMessage: "That fine steel sword? Only 25 gold pieces! It's a bargain for such craftsmanship. Would you like to purchase it?",
                        options: [
                            { text: "I'll take it!", nextStep: "buy_sword" },
                            { text: "That's a bit expensive.", nextStep: "haggle" },
                            { text: "Let me think about it.", nextStep: "greeting" }
                        ]
                    },
                    magical_weapons: {
                        shopkeeperMessage: "For a discerning customer like yourself, I might have something special... This crystal-infused blade can cut through armor like butter and glows when enemies are near.",
                        options: [
                            { text: "How much for the magical sword?", nextStep: "magic_sword_price" },
                            { text: "I'll stick with regular weapons for now.", nextStep: "weapons" },
                            { text: "Let me browse your other items.", nextStep: "greeting" }
                        ]
                    },
                    healing_potions: {
                        shopkeeperMessage: "My healing potions are brewed with rare herbs from the Misty Forest. 5 gold coins for a standard vial that will heal most wounds instantly.",
                        options: [
                            { text: "I'll take a healing potion.", nextStep: "buy_potion" },
                            { text: "Do you have stronger healing potions?", nextStep: "strong_healing" },
                            { text: "Let me look at something else.", nextStep: "greeting" }
                        ]
                    },
                    buy: {
                        shopkeeperMessage: "Excellent! Here's what I have available today. What would you like to purchase?",
                        options: [
                            { text: "Show me your weapons", nextStep: "weapons" },
                            { text: "I need potions", nextStep: "potions" },
                            { text: "Let me see that magical crystal", nextStep: "crystal" },
                            { text: "On second thought, just browsing", nextStep: "browsing" }
                        ]
                    },
                    buy_sword: {
                        shopkeeperMessage: "A fine choice! This sword has served many heroes well. Use it wisely! *hands you the steel sword*",
                        options: [
                            { text: "Thank you! Do you have anything else to go with it?", nextStep: "accessories" },
                            { text: "Thanks! I'll be on my way now.", nextStep: "farewell" }
                        ]
                    },
                    buy_potion: {
                        shopkeeperMessage: "Here's your healing potion! Remember to drink it all in one go for the full effect. *hands you a red glowing vial*",
                        options: [
                            { text: "Thanks! Any advice on using it?", nextStep: "potion_advice" },
                            { text: "I appreciate it. Let me browse more.", nextStep: "greeting" }
                        ]
                    },
                    farewell: {
                        shopkeeperMessage: "Safe travels, adventurer! May your blade stay sharp and your wits sharper! Return any time.",
                        options: [
                            { text: "Goodbye, shopkeeper!", nextStep: "end_chat" }
                        ]
                    },
                    end_chat: {
                        shopkeeperMessage: "Farewell!",
                        options: []
                    }
                };
                
                // Show chat prompt with greeting
                function showChatPrompt() {
                    const chatWindow = document.getElementById('chat-window');
                    chatWindow.classList.remove('hidden');
                    chatWindow.classList.add('active');
                    chatActive = true;
                    
                    // Start dialogue with greeting
                    updateDialogue('greeting');
                }
                
                // Update dialogue based on current step
                function updateDialogue(step) {
                    currentDialogueStep = step;
                    const dialogue = dialogueTree[step];
                    const chatMessages = document.getElementById('chat-messages');
                    const chatOptions = document.getElementById('chat-options');
                    
                    // Add shopkeeper message
                    if (dialogue.shopkeeperMessage) {
                        const shopkeeperMsg = document.createElement('div');
                        shopkeeperMsg.className = 'chat-message shopkeeper-message';
                        shopkeeperMsg.textContent = dialogue.shopkeeperMessage;
                        chatMessages.appendChild(shopkeeperMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        
                        // Update speech bubble with the first part of the message
                        const shortMessage = dialogue.shopkeeperMessage.split('.')[0] + '.';
                        document.getElementById('speech-bubble').textContent = shortMessage;
                    }
                    
                    // Clear previous options
                    chatOptions.innerHTML = '';
                    
                    // Add new dialogue options
                    dialogue.options.forEach(option => {
                        const optionButton = document.createElement('button');
                        optionButton.className = 'chat-option';
                        optionButton.textContent = option.text;
                        optionButton.addEventListener('click', () => {
                            // Add player response to chat
                            const playerMsg = document.createElement('div');
                            playerMsg.className = 'chat-message player-message';
                            playerMsg.textContent = option.text;
                            chatMessages.appendChild(playerMsg);
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                            
                            // If the option leads to buying something, show notification
                            if (option.nextStep === 'buy_sword') {
                                showNotification('Purchased Steel Sword!');
                            } else if (option.nextStep === 'buy_potion') {
                                showNotification('Purchased Healing Potion!');
                            }
                            
                            // If the nextStep is end_chat, close the chat window
                            if (option.nextStep === 'end_chat') {
                                setTimeout(() => {
                                    const chatWindow = document.getElementById('chat-window');
                                    chatWindow.classList.remove('active');
                                    setTimeout(() => {
                                        chatWindow.classList.add('hidden');
                                        chatActive = false;
                                    }, 300);
                                }, 1000);
                            } else {
                                // Otherwise, update dialogue with next step
                                setTimeout(() => {
                                    updateDialogue(option.nextStep);
                                }, 500);
                            }
                        });
                        chatOptions.appendChild(optionButton);
                    });
                }
                
                // Close chat button event listener
                document.getElementById('close-chat-btn').addEventListener('click', function() {
                    const chatWindow = document.getElementById('chat-window');
                    chatWindow.classList.remove('active');
                    setTimeout(() => {
                        chatWindow.classList.add('hidden');
                        chatActive = false;
                    }, 300);
                });
                
                console.log('Starting animation loop');
                // Start animation loop
                animate();
                
                // Show success message
                showNotification('Scene loaded successfully!');
                
            } catch (error) {
                console.error('Error initializing Three.js scene:', error);
                document.getElementById('loading').innerHTML = 'Error: ' + error.message;
            }
        }
    </script>
</body>
</html> 